// Generated by CoffeeScript 1.6.2
(function() {
  var animate, ballDeltaX, ballDeltaY, ballRadius, ballX, ballY, brickHeight, brickWidth, bricks, bricksPerRow, canvas, collisionXWithBricks, collisionYWithBricks, context, createBricks, displayScoreBoard, drawBall, drawBrick, drawPaddle, end, explodeBrick, f2T, fps, friction, interval, keys, mainLoop, moveBall, movePaddle, now, paddleDeltaX, paddleDeltaY, paddleHeight, paddleMove, paddleSpeedX, paddleWidth, paddleX, paddleY, score, start;

  canvas = document.getElementById("canvas");

  context = canvas.getContext("2d");

  paddleX = 200;

  paddleY = 460;

  paddleWidth = 50;

  paddleHeight = 20;

  paddleDeltaX = 0;

  paddleDeltaY = 0;

  ballX = 300;

  ballY = 300;

  ballRadius = 6;

  bricksPerRow = 8;

  brickHeight = 20;

  brickWidth = canvas.width / bricksPerRow;

  bricks = [[1, 1, 1, 1, 1, 1, 1, 2], [1, 1, 3, 1, 0, 1, 1, 1], [2, 1, 2, 1, 2, 1, 0, 1], [1, 2, 1, 1, 0, 3, 1, 1]];

  score = 0;

  ballDeltaX = null;

  ballDeltaY = null;

  paddleMove = null;

  paddleDeltaX = null;

  paddleSpeedX = 10;

  keys = [];

  friction = 0.8;

  fps = 60;

  interval = 1000 / fps;

  mainLoop = null;

  now = null;

  (function(window) {
    var cancelAnimationFrame, i, lastTime, requestAnimationFrame, vendors;

    lastTime = 0;
    vendors = ["webkit", "moz"];
    requestAnimationFrame = window.requestAnimationFrame;
    cancelAnimationFrame = window.cancelAnimationFrame;
    i = vendors.length;
    while (--i >= 0 && !requestAnimationFrame) {
      requestAnimationFrame = window[vendors[i] + "RequestAnimationFrame"];
      cancelAnimationFrame = window[vendors[i] + "CancelAnimationFrame"];
    }
    if (!requestAnimationFrame || !cancelAnimationFrame) {
      requestAnimationFrame = function(callback) {
        var nextTime;

        now = Date.now();
        nextTime = Math.max(lastTime + 16, now);
        return setTimeout((function() {
          return callback(lastTime = nextTime);
        }), nextTime - now);
      };
      cancelAnimationFrame = clearTimeout;
    }
    window.requestAnimationFrame = requestAnimationFrame;
    return window.cancelAnimationFrame = cancelAnimationFrame;
  })(window);

  drawPaddle = function() {
    context.fillStyle = "black";
    return context.fillRect(paddleX, paddleY, paddleWidth, paddleHeight);
  };

  drawBall = function() {
    context.fillStyle = "black";
    context.beginPath();
    context.arc(ballX, ballY, ballRadius, 0, Math.PI * 2, true);
    return context.fill();
  };

  createBricks = function() {
    var i, j, _results;

    i = 0;
    _results = [];
    while (i < bricks.length) {
      j = 0;
      while (j < bricks[i].length) {
        drawBrick(j, i, bricks[i][j]);
        j++;
      }
      _results.push(i++);
    }
    return _results;
  };

  drawBrick = function(x, y, type) {
    switch (type) {
      case 1:
        context.fillStyle = "orange";
        break;
      case 2:
        context.fillStyle = "rgb(100,200,100)";
        break;
      case 3:
        context.fillStyle = "rgba(50,100,50,.5)";
        break;
      default:
        context.clearRect(x * brickWidth, y * brickHeight, brickWidth, brickHeight);
    }
    if (type) {
      context.fillRect(x * brickWidth, y * brickHeight, brickWidth, brickHeight);
      return context.strokeRect(x * brickWidth + 1, y * brickHeight + 1, brickWidth - 2, brickHeight - 2);
    }
  };

  displayScoreBoard = function() {
    context.fillStyle = "black";
    context.font = "12px Helvetica";
    context.clearRect(0, canvas.height - 30, canvas.width, 30);
    return context.fillText("Score: " + score, 20, canvas.height - 25);
  };

  moveBall = function() {
    if (ballY + ballDeltaY - ballRadius < 0 || collisionYWithBricks()) {
      ballDeltaY = -ballDeltaY;
    }
    if ((ballX + ballDeltaX - ballRadius < 0) || (ballX + ballDeltaX + ballRadius > canvas.width) || collisionXWithBricks()) {
      ballDeltaX = -ballDeltaX;
    }
    if (ballY + ballDeltaY + ballRadius > canvas.height) {
      end();
    }
    if (ballY + ballDeltaY + ballRadius >= paddleY ? ballX + ballDeltaX >= paddleX && ballX + ballDeltaX <= paddleX + paddleWidth : void 0) {
      ballDeltaY = -ballDeltaY;
    }
    ballX = ballX + ballDeltaX;
    return ballY = ballY + ballDeltaY;
  };

  movePaddle = function() {
    if (keys[39]) {
      if (paddleDeltaX < paddleSpeedX) {
        paddleDeltaX += 2;
      }
    }
    if (keys[37]) {
      if (paddleDeltaX > -paddleSpeedX) {
        paddleDeltaX -= 2;
      }
    }
    paddleDeltaX *= friction;
    if (paddleX + paddleDeltaX < 0 || paddleX + paddleDeltaX + paddleWidth > canvas.width) {
      paddleDeltaX = 0;
    }
    return paddleX = paddleX + paddleDeltaX;
  };

  f2T = function(Delta, Speed) {
    return (Speed * Delta) * (fps / 1000);
  };

  collisionXWithBricks = function() {
    var brickX, brickY, bumpedX, i, j;

    bumpedX = false;
    i = 0;
    while (i < bricks.length) {
      j = 0;
      while (j < bricks[i].length) {
        if (bricks[i][j]) {
          brickX = j * brickWidth;
          brickY = i * brickHeight;
          if (((ballX + ballDeltaX + ballRadius >= brickX) && (ballX + ballRadius <= brickX)) || ((ballX + ballDeltaX - ballRadius <= brickX + brickWidth) && (ballX - ballRadius >= brickX + brickWidth))) {
            if ((ballY + ballDeltaY - ballRadius <= brickY + brickHeight) && (ballY + ballDeltaY + ballRadius >= brickY)) {
              explodeBrick(i, j);
              bumpedX = true;
            }
          }
        }
        j++;
      }
      i++;
    }
    return bumpedX;
  };

  collisionYWithBricks = function() {
    var brickX, brickY, bumpedY, i, j;

    bumpedY = false;
    i = 0;
    while (i < bricks.length) {
      j = 0;
      while (j < bricks[i].length) {
        if (bricks[i][j]) {
          brickX = j * brickWidth;
          brickY = i * brickHeight;
          if (((ballY + ballDeltaY - ballRadius <= brickY + brickHeight) && (ballY - ballRadius >= brickY + brickHeight)) || ((ballY + ballDeltaY + ballRadius >= brickY) && (ballY + ballRadius <= brickY))) {
            if (ballX + ballDeltaX + ballRadius >= brickX && ballX + ballDeltaX - ballRadius <= brickX + brickWidth) {
              explodeBrick(i, j);
              bumpedY = true;
            }
          }
        }
        j++;
      }
      i++;
    }
    return bumpedY;
  };

  explodeBrick = function(i, j) {
    bricks[i][j]--;
    if (bricks[i][j] > 0) {
      return score++;
    } else {
      return score += 2;
    }
  };

  animate = function() {
    context.clearRect(0, 0, canvas.width, canvas.height);
    createBricks();
    moveBall();
    movePaddle();
    drawPaddle();
    drawBall();
    return displayScoreBoard();
  };

  start = function() {
    mainLoop = requestAnimationFrame(start);
    animate();
    document.body.addEventListener("keydown", function(e) {
      return keys[e.keyCode] = true;
    });
    return document.body.addEventListener("keyup", function(e) {
      return keys[e.keyCode] = false;
    });
  };

  end = function() {
    cancelAnimationFrame(mainLoop);
    mainLoop = null;
    return context.fillText('The End!', canvas.width / 2, canvas.height / 2);
  };

  ballDeltaY = -6;

  ballDeltaX = -4;

  paddleMove = "NONE";

  start();

}).call(this);
